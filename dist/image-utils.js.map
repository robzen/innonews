{"version":3,"sources":["../image-utils.js"],"names":[],"mappings":"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","file":"image-utils.js","sourcesContent":["require(\"babel-polyfill\");\r\nconst Jimp = require('jimp');\r\nconst request = require('request');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst mkdirp = require('mkdirp');\r\n\r\nfunction ImageUtils() {}\r\n\r\nImageUtils.prototype.download = (imageUrl, fileName) => {\r\n    return new Promise((resolve, reject) => {\r\n        request.get({url: imageUrl, encoding: 'binary'}, (err, response, body) => {\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                let contentType = response.headers['content-type'];\r\n                if (contentType) {\r\n                    //extract extension from header and use it for the filename\r\n                    const extension = contentType.split('/')[1];\r\n                    const fileNameWithExtension = fileName + '.' + extension;\r\n\r\n                    createNeededFolders(fileName)\r\n                        .then(() => {\r\n                            //save as image\r\n                            fs.writeFile(fileNameWithExtension, body, 'binary', err => {\r\n                                if (err) {\r\n                                    reject('error while writing file: ' + err);\r\n                                } else {\r\n                                    resolve(fileNameWithExtension);\r\n                                }\r\n                            });\r\n                        })\r\n                        .catch(err => {\r\n                            reject('error while creating necessary folders: ' + err);\r\n                        });\r\n                } else {\r\n                    reject('no content-type in header!');\r\n                }\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nImageUtils.prototype.edit = (imgFile, width, height, paddingBottom, text) => {\r\n    const txtPadding = 3;\r\n    const backgroundImgFileName = 'bg.png';\r\n\r\n    return new Promise((resolve, reject) => {\r\n        Jimp.loadFont(Jimp.FONT_SANS_16_WHITE)\r\n            .then(font => {\r\n                const textLines = countLines(font, width, text);\r\n                const textHeight = textLines * font.common.lineHeight;\r\n\r\n                return Jimp.read(backgroundImgFileName)\r\n                    .then(bgImg => {\r\n                        return bgImg.crop(0, 0, width, height);\r\n                    }).then(croppedBg => {\r\n                        Jimp.read(imgFile).then(newsImg => {\r\n                            return newsImg.cover(width, height - paddingBottom - textHeight - txtPadding*2);\r\n                        }).then(coveredNewsImg => {\r\n                            return croppedBg.composite(coveredNewsImg, 0, 0);\r\n                        }).then(finalImage => {\r\n                            return finalImage.print(font, txtPadding, height - textHeight - paddingBottom - txtPadding, text, width);\r\n                        }).then(printedImage => {\r\n                            printedImage.write(imgFile);\r\n                            resolve(imgFile);\r\n                        }).catch(err => {\r\n                            reject(err);\r\n                        });\r\n                    });\r\n            }).catch(err => {\r\n                reject(err);\r\n        });\r\n    });\r\n};\r\n\r\n/*ImageUtils.prototype.getErrorImage = (width, height) => {\r\n    const errorImgFileName = 'error.png';\r\n\r\n    return new Promise((resolve, reject) => {\r\n        Jimp.read(errorImgFileName)\r\n            .then(errorImg => {\r\n                return errorImg.resize(width, height);\r\n            }).then(resizedErrImg => {\r\n                resizedErrImg.getBuffer(Jimp.MIME_PNG, (err, buffer) => {\r\n                    if(err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(buffer);\r\n                    }\r\n                });\r\n            }).catch(err => {\r\n                    reject(err);\r\n            })\r\n    });\r\n};*/\r\n\r\nfunction createNeededFolders(filePath) {\r\n    return new Promise((resolve, reject) => {\r\n        //cuts the filename so you only have the folder path\r\n        const parsedPath = path.parse(filePath);\r\n\r\n        //creates necessary folders\r\n        mkdirp(parsedPath.dir, err => {\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                resolve(path);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction countLines(font, maxWidth, text) {\r\n    const words = text.split(' ');\r\n    let line = '', lines = 1;\r\n\r\n    for (let n = 0; n < words.length; n++) {\r\n        let testLine = line + words[n] + ' ';\r\n        let testWidth = measureText(font, testLine);\r\n        if (testWidth > maxWidth && n > 0) {\r\n            line = words[n] + ' ';\r\n            ++lines;\r\n        } else {\r\n            line = testLine;\r\n        }\r\n    }\r\n\r\n    return lines;\r\n\r\n    function measureText(font, text) {\r\n        let x = 0;\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (font.chars[text[i]]) {\r\n                x += font.chars[text[i]].xoffset\r\n                    + (font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0)\r\n                    + (font.chars[text[i]].xadvance || 0);\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n}\r\n\r\nmodule.exports = ImageUtils;"]}